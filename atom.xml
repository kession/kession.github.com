<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Octopress Blog]]></title>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2012-10-21T23:00:10+08:00</updated>
  <id>http://yoursite.com/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Test Octopress Blog]]></title>
    <link href="http://yoursite.com/blog/2012/10/21/test-octopress-blog/"/>
    <updated>2012-10-21T22:20:00+08:00</updated>
    <id>http://yoursite.com/blog/2012/10/21/test-octopress-blog</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lucene And Solr Config]]></title>
    <link href="http://yoursite.com/blog/2012/10/11/Lucene-and-solr-config/"/>
    <updated>2012-10-11T00:00:00+08:00</updated>
    <id>http://yoursite.com/blog/2012/10/11/Lucene-and-solr-config</id>
    <content type="html"><![CDATA[<p>﻿&#8212;
layout: post
title: &#8220;lucene索引基础知识solr配置&#8221;
date: 2012-10-11 22:20
comments: true</p>

<h2>categories: solr</h2>

<h2>一、搜索引擎创建和搜索索引过程</h2>

<p>在非结构化数据中，文档包含字符串，从文档搜索可得到字符串；而要从已知字符串搜索包含该字符串的文件即是从字符串到文档的映射，是从文档到字符串的反向过程，保存这种信息的索引称为<strong>反向索引</strong>（倒排索引）。
倒排索引左边是词典，每个词都保存着包含该字符串的文档列表。</p>

<h3>1. 创建索引过程</h3>

<pre><code> 文档(Document)
       ↓
 ------------------------------
    分词组件(Tokenizer)
    1. 文档分成一个个单词
    2. 去除标点
    3. 去除停词(stop word)
 ------------------------------
    词元(Token)
       ↓
 ------------------------------------------------
    语言处理组件(Linguistic Processor)
   英文：
   1. 变小写
   2. 缩减(stemming)为词根  [cars-&gt;car]
   3. 变换(lemmatizatic)为词根[driven -&gt;drive]
 -------------------------------------------------
     ↓
   词(Term)
     ↓
 ---------------------------------------
  索引组件(Indexer)
  1. 利用Term创建词典
  2. 排序
  3. 合并相同的词 生成倒排链表
 ---------------------------------------
     ↓
 倒排链表
</code></pre>

<h3>2. 搜索索引过程</h3>

<p>(1). 用户输入查询语句</p>

<pre><code>    A AND B NOT C
</code></pre>

<p>(2). 查询语句分析</p>

<ul>
<li>词法分析( 识别关键字和单词 )</li>
<li>语法分析( 生成语法树 )</li>
</ul>


<p>(3). 搜索索引,得到符合语法树的文档
在倒排表中取出包含A、B和C的文档链表</p>

<p>(4). 排序输出结果
根据得到的文档和查询语句的相关性，对结果进行排序。</p>

<ul>
<li>词的权重(Term weight)</li>
</ul>


<blockquote><p>计算词对文档的重要性，Term在文档的重要性有两个因素：</p>

<p><em>Term Frequency (ft)</em>: Term在Document出现的次数，越大越重要；</p>

<p><em>Document Frequency (df)</em>: 多少文档包含此Term，越大说明越不重要。</p>

<p><em>w = tf × log( n / df)</em></p></blockquote>

<ul>
<li>文档相关性

<blockquote><p>文档是由一系列词组成的，通过词之间的关系来判断文档的相关性，利用向量空间模型算法(VSM)。把所有搜索出来的文档向量和查询向量放到一个N维空间，两个向量夹角越小相似度越高(余弦相似定理)。</p></blockquote></li>
</ul>


<h2>二、Lucene代码模块</h2>

<ul>
<li>analysis模块负责词法分析及语言处理得到Term；</li>
<li>index模块负责创建索引；</li>
<li>store模块负责索引读写；</li>
<li>QueryParser主要负责语法分析；</li>
<li>search模块负责索引搜索；</li>
<li>similarity模块负责相关性打分。

<h2>三、Lucene创建、查找索引</h2>

<p>索引过程：按照全文检索基本过程，将倒排表写成文件格式过程；</p></li>
</ul>


<p>搜索过程：按照文件格式读取索引，计算每篇文本得分的过程。</p>

<h2>四、Lucene索引格式</h2>

<h3>索引层次结构：</h3>

<ul>
<li>索引(index)：同一个文件夹内所有文件构成一个Lucene索引</li>
<li>段(segment)：相同前缀的文件属同一个段</li>
<li>文档(document)：不同的文档保存在不同的段中，一个段包含多个文档；</li>
<li>域(field)：文档的不同列信息；</li>
<li>词(term)：索引最小单位。

<h3>正向信息：</h3>

Index→Segment(segments.gen, segments_N)→Field(fnm, fdx, fdt)→Term(tvx, tvd, tvf)
段的真正信息保存在域和词中，segment文件只是元数据信息。

<blockquote><ul>
<li>segments_N保存了些索引包含多少个段，每个段包含了多少篇文档；</li>
</ul>
</blockquote></li>
<li>XXX.fnm保存了此段包含了多少个域，每个域的名称及索引方式；</li>
<li>XXX.fdx，XXX.fdt保存了此段包含的所有文档，每篇文档包含了多少域，每个域保存了哪些信息；</li>
<li>XXX.tvx，XXX.tvd, XXX.tvf保存了此段包含多少文档，每篇文档包含多少域，每个域包含了多少词，每个词的字符串，位置等信息。

<h3>反向信息：</h3>

保存了词典到倒排表的映射：Term→Document

<blockquote><ul>
<li>XXX.tis，XXX.tii保存了词典，此段包含所有的词按字典顺序排序；</li>
</ul>
</blockquote></li>
<li>XXX.frq 保存了倒排表，每个词的文档ID列表</li>
<li>XXX.prx保存了倒排表个每个词在包含此词的文档中的位置</li>
</ul>


<h2>五、solr配置文件参数</h2>

<h3>1. schema.xml</h3>

<p>字段配置<a href="http://wiki.apache.org/solr/SchemaXml">schema.xml</a>l定义了加入索引的数据的数据类型</p>

<pre><code>&lt; fieldType name =" string " class =" solr.StrField " sortMissingLast =" true " omitNorms =" true " /&gt;
</code></pre>

<ul>
<li><em>indexed</em> 需要被索引的field</li>
<li><em>stored</em> 需要被存储的field, 如果仅需要存储作为其它域查询结果的话, 则不需要设indexed, 仅需要stored即可;</li>
<li><em>sortMissingLast=&#8221;true&#8221;</em> 表示此filed没有数据时的文档排在有数据文档之后, 而不 管请求时的排序规则;</li>
<li><em>sortMissingFirst=&#8221;true&#8221;</em> 类似;</li>
<li><em>omitNorms=&#8221;true&#8221; </em>表示不关心字段长段(或不使用存储规范)和索引时不计算boost，可以节省内存空间. 只有文本字段需要关心，所以一般文本字段不设置为true;</li>
<li><em>compressed=true|flase</em> 使用gzip压缩field, 用于TextField和StrField;</li>
<li><em>multiValued=true|false</em> 该field在文档中出现多次时设多值为true, 即文档可以拥有相同名称的多个field;</li>
<li><strong>Expert field options</strong> termVectors=false|true &lt;?> Solr 1.1

<blockquote><p>If set, include full term vector info.
If enabled, often also used with termPositions=&#8221;true&#8221; and termOffsets=&#8221;true&#8221;.
To use interactively, requires TermVectorComponent
Corresponds to TV button in Luke, and V field attribute.</p></blockquote></li>
</ul>


<h3>2. solrconfig.xml</h3>

<p><a href="http://wiki.apache.org/solr/SolrConfigXml">solrconfig.xml</a> 配置solr自身的一些参数
<a href="http://svn.apache.org/repos/asf/lucene/dev/trunk/solr/example/solr/collection1/conf/solrconfig.xml">solrconfig.xml示例+注释</a></p>

<h4>索引配置</h4>

<ul>
<li><em>useCompoundFile=&#8221;true&#8221;</em>表示使用单文件索引格式(复合索引格式)，减少每次打开文件的数目, 会增加索引时间;

<blockquote><p><strong>非复合索引格式</strong></p></blockquote></li>
</ul>


<table>
    <tr>
        <td>segment</td>
        <td>field</td>
        <td>term</td>
    </tr>
    <tr>
         <td> segments.gen </td>
         <td>_0.fdx</td>
         <td>_0.tvx</td>
    </tr>
     <tr>
         <td> segments_N </td>
         <td>_0.fnm</td>
         <td>_0.tvd</td>
    </td>
         <tr>
         <td>   </td>
         <td>_0.fdt</td>
         <td>_0.tvx</td>
    </td>
</table>


<blockquote><p><strong>复合索引格式</strong></p></blockquote>

<table>
    <tr>
        <td>segment</td>
        <td>field term</td>
        <td>  </td>
    </tr>
    <tr>
         <td> segments.gen </td>
         <td>_0.cfs</td>
         <td> </td>
    </tr>
     <tr>
         <td> segments_N </td>
         <td>_0.cfs</td>
         <td> </td>
</table>


<p></p>

<ul>
<li><em>mergeFactor</em> 控制一次合并多少个段(segment)，或合并频率，值小使用内存少, 索引时间变长; 值大使用内存加大, 索引时间变小. 默认值10.(当大小相当的段的数量达到此值时开始合并)</li>
<li><em>ramBufferSizeMB</em>和 <em>maxBufferedDocs</em>

<blockquote><p>段合并发生在添加完一篇文档后, 添加完一篇文档后, 如果内存达到用户设定的ramBufferSize或者maxBufferedDocs, 则写入文件系统, 形成一个新的段. 新段加入可能造成差不多大小的段个数达到mergeFactor, 则开始合并过程;</p></blockquote></li>
</ul>


<blockquote><p><em>ramBufferSizeMB</em>和 <em>maxBufferedDocs</em>可以同时使用, <strong>不要</strong>随意设置MaxbufferedDocs。MaxBufferedDocs和RAMBufferSize共同控制内存中文档的容量, MaxbufferedDocs本身是disabled，设置不合理将导致大规模的重建索引非常慢。</p>

<h2>六、 minisearch接下来工作</h2></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Json Return Failed]]></title>
    <link href="http://yoursite.com/blog/2012/09/28/Json-Return-Failed/"/>
    <updated>2012-09-28T00:00:00+08:00</updated>
    <id>http://yoursite.com/blog/2012/09/28/Json-Return-Failed</id>
    <content type="html"><![CDATA[<h2>异步请求返回JSON为空常见原因</h2>

<hr />

<p><strong>问题描述:</strong>在进行异步请求的时候，有时会遇到程序完成返回，结果的JSON串为空的情况。首先确保程序Debug能return ModelAndView，一般原因有以下两种：</p>

<h3>1. Float字段转换出错导致</h3>

<p> Float类型数据在返回时可能会造成ModelAndView转换为JSON串时失败，有一个对象转换失败则整个JSON串返回为空。可以新建一Bean专门用于返回，将BO取得的对象拷贝过来。</p>

<h3>2.  Controller接受多个对象导致</h3>

<p>Controller用于接受的参数可为多个参数，但多个参数只能为基本数据类型；或者接受单一对象作为参数。多个对象作为参数传递时，可改为多个基本数据类型传递，手动new对象处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bp Xselect]]></title>
    <link href="http://yoursite.com/blog/2012/09/24/bp-xselect/"/>
    <updated>2012-09-24T00:00:00+08:00</updated>
    <id>http://yoursite.com/blog/2012/09/24/bp-xselect</id>
    <content type="html"><![CDATA[<p>Included file &#8216;JB/setup&#8217; not found in _includes directory</p>

<h2>xselect</h2>

<hr />

<h3>1. 基本用法  <a href="http://setao.alibaba-inc.com/lib/lib/120.htm">详细点击</a></h3>

<p>其中<em>base</em> 为xselect父节点div ID，<strong>注意 <code>#</code></strong> ， <em>id</em>设置xselect的id，<strong>无需 <code>#</code></strong>.</p>

<pre><code>var selectDate =  [{label:'全部',value:'-1'}, {label:'新签',value:'1'},{label:'续签',value:'2'};
var sel = new Lite.ui.Xselect({
    base : '#bp-tradetype',  
    data : selectDate,
    key: {
           label: 'label',
           value: 'value'
    },
    id : 'bss-select-salesorg-ID',
    name : '_tradeType',
    css : { width : 70 },
    onChange:function(value){
        // onChange Event do something
    }
});
</code></pre>

<h3>2. 取值</h3>

<pre><code>// 取得选择项的 value 值
var v = $("#bss-select-salesorg-ID").val();
// 取得选择项的 label 值
var l = $("li.lt-menuitem[rel="+ salesOrgID +"]").html();
</code></pre>

<h3>3. json传值初始化</h3>

<pre><code>var sel = new Lite.ui.Xselect({
    base : '#selectSalesName',  
    key: {
           label: 'salesOrgName',
           value: 'salesOrgID'
    },
    id : 'bss-select-salesorg-ID',
});
s1.init(selectDate);
</code></pre>

<h3>4. 默认值</h3>

<pre><code>// 设置默认值
var selectDate = [{salesOrgName:'全部',salesOrgID:'-1'}];
selectDate = selectDate.concat(res.d.salesOrgList);
s1.init(selectDate);
// 默认选择
s1.value('-1');
</code></pre>
]]></content>
  </entry>
  
</feed>
